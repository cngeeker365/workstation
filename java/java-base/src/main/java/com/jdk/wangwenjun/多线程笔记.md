# 0. 多线程场景分析
# 1. 线程生命周期
# 2. 多线程与JVM内存结构的关系
# 3. Thread构造函数StackSize详解
# 4. Daemon线程的创建及场景分析
# 5. API及应用场景
## 5.1 id
## 5.2 priority
## 5.3 join
## 5.4 interrupt
## 如何关闭线程（优雅、强制）
# 6. Synchronized
## 6.1 结合jconsole、jstack及汇编指令认识（基于Bank场景）
    * jps：获取线程id
    * jstack pid：查看自定义名字的Thread，可以看到一个线程持有Monitor的锁、等待的锁
    * javap -c path/to/build-class：查看编译后的反汇编的内容
## 6.2 同步方法、同步代码块的区别与联系
## 6.3 this锁、class锁（静态方法或静态代码块）
# 7. 线程间通信
## 7.1 wait、notify、notifyAll
## 7.2 sleep、wait的区别
    * sleep 是 Thread 的方法，wait 是 Object 的方法
    * sleep 不会释放锁，wait 会释放锁并加入锁等待队列
    * sleep 不依赖锁，wait 需要
    * sleep 不需要唤醒，wait 需要
# 8. 调试手段
    * 线程Exception捕获
    * StackTrace堆栈跟踪
    * Runtime 给程序注入 hook
        在 main 函数中加入 hook，以便起到通知、释放资源的目的
        * kill pid：可以执行hook
        * kill -9 pid：没有机会执行hook
    * jvm模式
        * client模式
        * server（JIT）模式：手动指定 或 堆内存超过1024
# 9. Thread、ThreadGroup
# 10. 线程池
    * 原理
        * 任务队列 taskQueue
        * 拒绝策略 discard（抛出异常、直接丢弃、阻塞、临时队列）
        * init（min）
        * active
        * max
# 11. 单例模式
    * 饿汉式
    * 线程不安全的懒加载
    * 方法加锁
    * Double-Check
    * volatile
    * 静态内部类
    * 枚举
# 12. waitSet 概念
# 13. volatile 
    * 特性
        * 一旦一个共享变量被 volatile 修饰，具备两层语义：
            * 保证了不同线程间的可见性
            * 禁止对其进行重排序，也就是保证了有序性
            * 并未保证原子性
        * 保证重排序时，不会把屏障前后的指令换位置
        * 强制对缓存的修改操作立刻写入主存
        * 若是写操作，则会导致其他 CPU 中的缓存失效
    * 应用场景
        * 标志位，即状态量标记
            volatile boolean start = true;
            while(start){ //TODO... }
            void close(){ start = false; }
        * 屏障前后的一致性（防止重排序，做状态判断）
        * 共享资源（内部属性，在多线程创建时，应加volatile修饰）
        
# 14. Java 内存模型
    * 内存：
        * RAM
        * ROM
    * CPU组成
    * 计算过程
        i=i+1
            cpu1：   main memory -> i -> cache i+1 -> cache -> main memory 
            cpu2：   main memory -> i -> cache i+1 -> cache -> main memory 
        会出现缓存不一致问题
            解决方法：
                1. 给数据总线加锁
                    总线：数据总线、地址总线、控制总线
                    LOCK
                2. CPU高速缓存一致性协议
                    Intel MESI
                核心思想：
                    1. 当CPU写入数据时，若发现该变量被共享（即，在其他CPU中存在该变量副本），则会发出信号通知其他CPU该变量的缓存无效
                    2. 当其他CPU访问该变量时，重新到主内存进行获取
# 15. 并发编程的三个重要概念
    * 原子性 A：
        * 保证一个或多个操作，要么都成功，要么都失败，中间不能由于任何因素中断。例如账户转账
        * 对基本数据类型的变量读取和赋值是保证了原子性的，要么都成功，要么都失败，这些操作不可被中断
            a=10    原子性
            b=a     不满足：1.read a；2.assign b；
            c++     不满足：1.read c；2.add；3.assign c
    * 可见性 V：
        * 例如：main memory：int i =0
             Thread-1   i = 10； cache【i=10】
             Thread-2   int j=i;    cache【j=0，i from main memory】
        * 使用 volatile 关键字保证可见性，即对变量的修改会立刻更新 main memory，使用时从 main memory 获取
    * 有序性 O:
        * 重排序只要求最终一致性
        * happens-before relationship
            * 一个线程内，代码的执行顺序，编写在前的发生在编写在后面的
            * unlock 必须发生在 lock 之后
            * volatile 修饰的变量，对该变量的写操作，先于对该变量的读操作（在多线程情况下）
            * 传递规则：操作A先于B，B先于C，则A必先于C
            * 线程启动规则：start 方法必先于线程 run
            * 线程中断规则：interrupt 动作必须发生在捕获该动作之前
            * 对象销毁规则：初始化必须发生在 finalize 之前
            * 线程终结规则：所有操作都发生在线程死亡之前
        * 不会影响单线程执行情况，但会影响多线程或多CPU的情况
            例如：
                -------------------Thread-1------------------
                obj = createObj()       初始顺序 1   重排顺序 2 
                init= true              初始顺序 2   重排顺序 1 ---> 导致Thread-2具备执行条件，但实际 obj 并未初始化完成
                
                -------------------Thread-2------------------
                while(!init){
                    sleep
                }
                useObj(obj)
# 16. 观察者模式
# 17. 单线程执行设计模式
# 18. 多线程 读写锁分离 设计模式
    * SharedResource：Data 
        1. read other thread will enter to the waitset
        2. read wirte：锁分离
    * concern conflict
        +--------------------------------------------------------+
        +                  |       READ        |      WRITE      |
        +--------------------------------------------------------+
        +       READ       |         N         |        Y        |
        +--------------------------------------------------------+
        +      WRITE       |         Y         |        Y        |
        +--------------------------------------------------------+
        
    
# 19. 多线程 不可变对象 设计模式
    * 不可变对象一定是线程安全的，里面的任何属性或引用类型的属性都不能被修改
        * String 即为不可变对象
    * 可变对象不一定是不安全的
# 20. 多线程 Future 设计模式
# 21. Guarded Suspension 设计模式
    适用场景：处理能力有限时，通过队列缓存，后续能力恢复时，处理
# 22. Thread-Specific Storage 线程保险箱 设计模式
# 23. ThreadLocal
# 24. 多线程 Balking 设计模式
# 25. 多线程 Producer-Consumer 设计模式
# 26. 多线程 Count Down 设计模式
# 27. 多线程 Thread-Per-Message 设计模式
# 28. 多线程 Two Phase Termination 设计模式
# 29. 多线程 Worker-Thread 设计模式
